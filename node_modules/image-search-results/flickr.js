'use strict';

let Flickr = require('flickrapi');

let size = 'z';

let Init = (config) => {
  return new Promise((res, rej) => {
    console.log('[FLICKR] INIT');
    Flickr.authenticate(config, (err, flickr) => {
      if (err) {
        rej(err);
      } else {
        res(flickr);
      }
    });
  });
};

let init;

let url = (params) => {
  return `https://farm${params.farm}.staticflickr.com/${params.server}/${params.id}_${params.secret}_${size}.jpg`;
};

let fetch = (flickr, {query = 'cat', count = 200, page = 1}) => {
  let p = new Promise((res, rej) => {
    flickr.photos.search({
      text: query,
      content_type: 1, // photos only
      media: 'photos',
      privacy_filter: 1, // public only
      sort: 'relevance',
      per_page: count,
      page: page
    }, (err, resp) => {
      if (err) {
        rej(err);
      } else {
        let urls = resp.photos.photo.map(x => url(x));
        res(urls);
      }
    });
  });

  return p;
};

let multiFetch = (flickr, params) => {
  if (params.count > 500) {
    let searchCount = Math.ceil(params.count / 500);
    let promises = [];
    for (let i = 1; i <= searchCount; i++){
      promises.push(fetch(flickr, {count: 500, page: i}));
    }
    return Promise.all(promises)
      .then((results) => {
        let merged = [].concat.apply([], results);
        return merged;
      })
      .then((urls, index) => {
        const out = urls.map((url, index) => ({
          url,
          resultIndex: index,
          source: 'flickr'
        }));
        return out;
      });
  } else {
    return fetch(flickr, params);
  }
};

module.exports = (config) => {
  init = init || Init(config);

  return (params) => {
    return init.then((flickr) => {
      return multiFetch(flickr, params);
    });
  };
};
